---
title: 'STL'
description: '算法学习之STL'
date: '2024-11-02'
categories: 'Algorithm'
---

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

// vector 变长数组，倍增的思想，自动变长（空间不够自动x2，尽量减少申请空间的次数
// 系统为某一程序分配空间时，所需时间与空间大小无关，与申请次数有关
// 平均情况下，可以看作每插入一个元素的时间为O(1)
#include <vector>
vector<int> a;

// pair是C++常见的模板，可以存储一个二元组
// pair的第一个元素用first表示，第二个元素用second表示，前后两个变量可以任意
pair<int, int>;

// string 字符串
string;

// queue 队列，队首队尾操作，时间复杂度O(1)
// 队尾插入队头弹出，是先进先出的数据结构
#include <queue>
queue<int>;

// priority_queue 优先队列（堆），队首操作，时间复杂度O(logn)
// 默认是大根堆
#include <queue>
priority_queue<int>;

// stack 栈，栈顶操作，类似于队列，时间复杂度O(1)
// 默认是后进先出
#include <stack>
stack<int>;

// deque 双端队列，队首队尾操作，时间复杂度O(1)
// 队首插入队尾弹出，是先进后出的数据结构
// 加强版vector,但速度慢(令人发指)
#include <deque>
deque<int>;

// set 集合，时间复杂度O(logn)
#include <set>
set<int>;      // 若输入了重复元素，则忽略该操作
multiset<int>; // 允许重复元素

// map 映射，时间复杂度O(logn)
#include <map>
map<int, int>;      // 若输入了重复元素，则忽略该操作
multimap<int, int>; // 允许重复元素

// bitset 压位
// 1个字节存8位，内存只用1/8
#include <bitset>
bitset<10000> b;

int main()
{
    vector<int> a;       // 定义一个vector
    vector<int> a(n);    // 定义一个长度为n的vector
    vector<int> a(n, m); // 定义一个长度为n的vector，每个元素初始化为m
    vector<int> a[n];    // 定义n个vector的数组

    // size和empty每个STL都有，时间复杂度O(1)
    a.size();       // 返回a的元素的个数
    a.empty();      // 判断a是否为空，为空返回true，否则返回false
    a.clear();      // 清空a中的所有元素，时间复杂度O(n)
    a.front();      // 返回a中第一个元素
    a.back();       // 返回a中最后一个元素
    a.push_back(x); // 将x插入a的末尾
    a.pop_back();   // 删除a中最后一个元素
    a.begin();      // 迭代器，返回a的第一个元素
    a.end();        // 迭代器，返回a的最后一个元素的下一个位置
    [];             // vector支持随机寻址

    // 三种遍历方式
    for (int i = 0; i < a.size(); i++)
        a.push_back(i);
    for (int i = 0; i < a.size(); i++)
    {
        cout << a[i] << " ";
    }
    // vector<int>::iterator可以写成auto，C++关键字，系统可以自己推断
    for (vector<int>::iterator i = a.begin(); i != a.end(); i++)
    {
        cout << *i << " ";
    }
    for (auto x : a)
    {
        cout << x << " ";
    }

    // vector支持比较运算，按字典序从小到大排序
    vector<int> a(4, 3), b(3, 4);
    if (a < b)
        puts("a < b");

    pair<int, string> p;

    p.first;
    p.second;

    // pair支持比较运算，以first为第一关键字，以second为第二关键字（字典序，可以看作长度为2的字符串）

    // 构造pair
    p = make_pair(1, "hello");
    p = {1, "hello"};
    p = pair<int, string>(1, "hello");

    // 假设我们有个东西有两种不同的属性，我们可以用pair来存储，我们可能需要按照某种属性来排序，需要排序的关键字放在first

    // pair也可以存储三个属性
    pair<int, pair<string, int>> p;

    string s = "hello";
    s.size();
    s.length(); // 和size()等价
    s.empty();
    s.clear();

    s += "world";
    s += 'a';

    s.substr(1, 10);           // 两个参数，第一个参数返回起始位置，第二个参数返回长度
    s.substr(1);               // 返回从位置1开始到结尾的字符串
    printf("%s\n", s.c_str()); // 用printf输出字符串，c_str()返回一个C风格的字符串（以'\0'结尾的字符数组)

    queue<int> q;
    q.size();
    q.empty();
    // 没有clear函数
    q = queue<int>(); // 初始化，重新构造一个队列，即清空
    q.push(x);        // 向队尾插入一个元素
    q.front();        // 返回队首元素
    q.back();         // 返回队尾元素
    q.pop();          //  弹出队头元素

    priority_queue<int> pq;
    pq.size();
    pq.empty();
    // 没有clear函数
    pq.push(x); // 队首插入元素
    pq.top();   // 返回堆顶元素
    pq.pop();   // 弹出堆顶元素

    // 如果要定义小根堆
    // 1.向堆中插入元素直接插入负数
    pq.push(-x);
    // 2.直接定义为小根堆
    priority_queue<int, vector<int>, greater<int>> pq;

    stack<int> st;
    st.size();
    st.empty();
    // 没有clear函数
    st.push(x); // 栈顶插入元素
    st.top();   // 返回栈顶元素
    st.pop();   // 弹出栈顶元素

    deque<int> dq;
    dq.size();
    dq.empty();
    dq.clear();
    dq.push_back(x);  // 队尾插入元素
    dq.push_front(x); // 队首插入元素
    dq.pop_back();    // 队尾删除元素
    dq.pop_front();   // 队首删除元素
    dq.front();       // 返回队首元素
    dq.back();        // 返回队尾元素
    [];               // 支持随机访问
    dq.begin();       // 返回队首迭代器
    dq.end();         // 返回队尾迭代器

    // set/multiset
    size()
            empty()
                clear()
                    insert() // 插入元素一个数
        find()               // 查找元素是否存在
        count()              // 返回某一个数的个数
        erase()              // 删除元素
                             // (1) 输入是一个数x，删除所有x  O(k + logn) k为x的个数
                             // (2) 输入是一个迭代器，删除这个迭代器指向的元素
        lower_bound() /
        upper_bound() // 最重要的两个函数
        lower_bound() // 返回第一个大于等于x的迭代器
        upper_bound() // 返回第一个大于x的迭代器,返回end()表示不存在

        // map/multimap
        size()
            empty()
                clear()
                    insert() // 插入的数是一个pair
        erase()              // 输入的参数是pair或者迭代器
        find()               // 输入的参数是一个数，返回一个迭代器指向这个数

            []; // 重要，牛逼，可以用像数组一样用map
    map<string, int> m;
    m["hhy"] = 1;

    lower_bound() / upper_bound() // 最重要的两个函数
        lower_bound()             // 返回第一个大于等于x的迭代器
        upper_bound()             // 返回第一个大于x的迭代器,返回end()表示不存在


    bitset<10000> b;
    ~, &, |, ^
    >>, <<
    ==, !=
    []; // 取出某一位是0是1

    count(); //返回有多少个1
    any(); // 是否有1
    none(); // 是否全为0
    set(); // 把所有位置为1
    set(k, v); // 把第k位设置为v
    reset(); // 把所有位置为0
    flip(k); // 把第k位取反
}
```

[访问我的Notion](https://pickle-headline-168.notion.site/STL-12b8ffd937e2806c821fd14dad9e2aa2?pvs=4)